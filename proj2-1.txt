James Carr cs61c-avg
Luke Levis cs61c-avd

1. The problem with this idea is that the number of ways of arranging 4 pieces is (4*3*2) = 24.  The total amount of permutations generated by our project is 12.  This is a 2:1 ratio, meaning that one desired outcome has (ways/2) options associated with it. The issue with your "friend's" idea, is that the other 12 are "valid" to him. For example 

---------
| 1 | 3 |
---------
| 2 | - |
---------

This is actually an impossible setup for the board, but the friend allows for this to happen but it is not physically possible if the board starts from a solved state and pieces are not out of order to begin with.


2. If we were to start from these 12 and run mapreduce from each seed, it would not be efficient and it would not use the solution() boolean function.  A better way that uses such a solution() boolean (true or false: is it in the set of solutions) would be to check solution() in the map function to see if its level should be set to 0.  That way, you accumulate the solution set during the mapreduce process.

3. Store in the key whether this board leads to a solution. This requires creating the full tree of board configurations and using the mapreduce process on that data. In the mapreduce process, map() will decide which ones lead to the solution by comparing each board to the tree, and assigning a True or False value for that (k,v) pair. reduce() will eliminate all false boards from the dataset.  Then, the output will be the boards that lead to the solution.  This works either frontwards or backwards (starting at either the solution or the full board with a peg missing).  The game is identical backwards as it is forwards.
